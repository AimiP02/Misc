import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
from torch.autograd import Variable

from model import LSTMModel
from data import Preprocessing

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
from mlxtend.plotting import plot_confusion_matrix

import parse
import numpy as np

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
torch.manual_seed(2023)

criteon = nn.BCELoss().to(device)
    
class CustomDataset(Dataset):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __len__(self):
        return len(self.x)
    
    def __getitem__(self, index):
        return self.x[index], self.y[index]

class Execute:
    
    def __init__(self, args):
        self.__init_data__(args)
        self.args = args
        self.batch_size = args.batch_size
        self.model = LSTMModel(args)
        self.model.to(device)
        
    def __init_data__(self, args):
        self.preprocessing = Preprocessing(args)
        self.preprocessing.load_data()
        self.preprocessing.prepare_tokens()
        
        raw_x_train = self.preprocessing.x_train
        raw_x_test = self.preprocessing.x_test
		
        self.y_train = self.preprocessing.y_train
        self.y_test = self.preprocessing.y_test

        self.x_train = self.preprocessing.sequence_to_token(raw_x_train)
        self.x_test = self.preprocessing.sequence_to_token(raw_x_test)
    
    def train(self):
        train_dataset = CustomDataset(self.x_train, self.y_train)
        test_dataset = CustomDataset(self.x_test, self.y_test)
        self.train_loader = DataLoader(train_dataset, batch_size=self.batch_size)
        self.test_loader = DataLoader(test_dataset)
        
        optimizer = optim.Adam(self.model.parameters(), lr=self.args.learning_rate)
        
        for epoch in range(self.args.epochs):
            predictions = []
            
            self.model.train()
            
            for api_list, label in self.train_loader:
                # print(label)
                b_api_list = api_list.type(torch.LongTensor).to(device)
                b_label = label.type(torch.FloatTensor).to(device)
                b_label = b_label.unsqueeze(1)
                
                y_pred = self.model(b_api_list)
                
                # print(b_label.min(), b_label.max())
                loss = criteon(y_pred, b_label)
                
                optimizer.zero_grad()
                
                loss.backward()
                
                optimizer.step()
                
                predictions += list(y_pred.squeeze().detach().cpu().numpy())
                
                # print("Epoch %d: loss: %.5f" % (epoch, loss.item()))
                
            test_predictions, test_loss = self.evaluation()
            
            train_accuracy = self.calculate_accuracy(self.y_train, predictions)
            test_accuracy = self.calculate_accuracy(self.y_test, test_predictions)
            
            print("Epoch: %d, Train loss: %.5f, Test loss: %5f, Train accuracy: %.5f, Test accuracy: %.5f" % (
                epoch+1, loss.item(), test_loss.item(), train_accuracy, test_accuracy
            ))


    def evaluation(self):
        predictions = []
        self.model.eval()
            
        with torch.no_grad():
                
            for api_list, label in self.test_loader:
                b_api_list = api_list.type(torch.LongTensor).to(device)
                b_label = label.type(torch.FloatTensor).to(device)
                b_label = b_label.unsqueeze(1)
            
                y_pred = self.model(b_api_list)
                
                loss = criteon(y_pred, b_label)
                
                predictions += list(y_pred.detach().cpu().numpy())
                
        return predictions, loss


    @staticmethod
    def calculate_accuracy(targets, predictions):
        true_positives = 0
        true_negatives = 0
        
        for target, pred in zip(targets, predictions):
            if (pred > 0.5) and (target == 1):
                true_positives += 1
            elif (pred < 0.5) and (target == 0):
                true_negatives += 1
            else:
                pass
            
        return (true_positives + true_negatives) / len(targets)
    
    def dosomething(self):
        predictions = []
        for api_list, label in self.test_loader:
            # print(api_list)
            
            api_list = api_list.type(torch.LongTensor).to(device)
            label = label.type(torch.FloatTensor).to(device)
            
            test_output = self.model(api_list)
            pred_y = np.round(test_output.cpu().detach().numpy()).astype(int)
            
            predictions.extend(pred_y.tolist())
        
        cm = confusion_matrix(self.y_test, predictions)
        plot_confusion_matrix(conf_mat=cm,
                              show_absolute=True,
                              show_normed=True,
                              colorbar=True)
        plt.savefig("confusion_matrix.png")
        plt.show()
    
    def save_model(self):
        torch.save(self.model, "model.pt")

if __name__ == "__main__":
    args = parse.parameter_parser()
    execute = Execute(args)
    execute.train()
    execute.dosomething()
    execute.save_model()